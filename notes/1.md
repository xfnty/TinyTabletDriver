Software requirement â€“ **condition** or **capability** needed by a user to **solve a problem**.

# Requirements

User (me) needs a program that would make my drawing tablet usable for playing video games and 
making drawings in digital painting software.

When I use the tablet for playing video games, Osu! in particular, I need the driver to consume as
little CPU resources as possible while having the low input latency. I also need it to be reliable 
and to not get in my way in general. Additionaly, I need to be able to adjust active area of the 
tablet.

When I use the tablet for drawing I need it to synthesize Windows Ink events, use whole tablet area
and allow binding mouse or keyboard buttons to pen buttons.

In general, I want to configure this program once and then never touch it again. I want it to "just 
work" in the background and not make me anxious about how it affects my system's performance. 
However I need to be able to switch between presets or edit them while the program is running.

It would be great to be able to analyze errors in the program that happened on user machine.

The program needs to support only one active tablet on the main monitor.

I also want to make it complete enough, to not be ashamed to show it to other people, primarily
other programmers, and to make it so other people could potentially consider actually using it.

Key points:
- One tablet, one monitor
- Configure tablet using user presets that specify output mode, active area and button bindings
- Select active preset at runtime
- Edit presets at runtime
- Efficiency
- Stability
- Transparency
- Completeness

# Constraints, Context and Implementation Ideas

The program will be developed using C, MSVC and Windows API on and for Windows 10.

Because I already have an idea of how to handle a tablet device, the following is going to be done:
- Tablets will be discovered by predefined vendor and product IDs and initialized using `SetupDi` 
  and `HidD` functions.
- Whether a tablet device is disconnected or not will be decided from the return value of `ReadFile` 
  on tablet's device handle.
- New tablets will be discovered by `CM_NOTIFY_CALLBACK` set up by `CM_Register_Notification`.

Watching for changes in user presets could be done using `ReadDirectoryChangesW`.

The program can use a tray icon for runtime configuration with the following menus:
- Presets
  - (list of user presets)
- Exit

`TrackPopupMenu` used to show tray menu is blocking and will need to be called from a separate 
thread.

Also `TrackPopupMenu` does not require a parent window, which means, I could get away with having no 
invisible root window for recieving messages and only using thread message pump.

`CM_NOTIFY_CALLBACK` is going to be registered on the main thread and will initialize the connected
device and send `WM_DEVICE_CONNECTED` to the main thread message queue.

The code responsible for reading the tablet packets will reset active tablet device and send 
`WM_DEVICE_LOST` to the main message queue when `ReadFile` fails.

The program is going to be waiting 99.9% of the time in main thread's message pump for the following 
things:
- Completion of an async read on tablet's device handle
- `OVERLAPPED.hEvent` passed to `ReadDirectoryChangesW` opened for user presets directory
- `WM_QUIT` and `WM_PRESET` messages sent from tray menu thread to the main thread
- `WM_DEVICE_CONNECTED` and `WM_DEVICE_LOST` messages

Logs should ideally be stored in files. File IO must be done on a seprate thread. They should 
include a crash report with backtrace and core dump.

Log messages should include:
- Thread ID
- File, line and function
- Severity or log level (info, error, non-recoverable/critical error)

When the program crashes it should show a message box with a reason for a crash and an option to 
open crash log in a text editor. This could be implemented using `TaskDialog` function.

User preset must specify the following:
- Name
- Output mode:
  - Mouse
  - Windows Ink
- Active area rectangle:
  - Top-left coordinate and the size of the rectangle in percents
  - Rotation of the rectangle around its top-left corner in degrees

It can be stored in a simple `.ini` file:
```ini
[general]
name=Drawing
mode=ink

[area]
top=0
left=0
width=100
height=100
rotation=0

[bindings]
tip=LMB
1=RMB
2=ctrl alt
```
```ini
[general]
name=Osu
mode=mouse

[area]
top=49
left=27.54
width=99
height=55.09
rotation=-90

[bindings]
tip=LMB
1=RMB
```

Binding IDs:
- `LMB`, `RMB`, `MMB` for mouse buttons
- `a-zA-Z0-9` for alphabet and numbers
- `ctrl`, `alt`, `shift` for modifiers
- `space`, `esc`, `enter`, `tab`, `del`, `backspace`, `home`, `end` etc. for special keys
- `f1-f12` for function keys
- `up`, `down`, `left`, `right` for arrows
- and so on

Errors in preset files could be signaled using message boxes with an option to open the file in a 
text editor.

Tablet-specific data is the following:
- VID, PID
- Human-friendly name
- `HidD_SetFeature` byte array
- Active area dimensions in millimeters
- Number of buttons available

Tablet packet parser should return the following data:
- Pressure (0 to 1)
- Pointer position (0 to 1 on both axises)
- Whether the pointer is down (true or false)
- Button states (true or false for the defined number of buttons)
